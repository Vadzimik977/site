import {
    useTonAddress,
    useTonWallet,
    useIsConnectionRestored,
  } from "@tonconnect/ui-react";
  import Footer from "./Footer";
  import Header from "./Header";
  import { createContext, useEffect, useState } from "react";
  import BorderAnimation from "../assets/js/animatedBorder";
  import marketAdaptiv from "../assets/js/marketAdaptiv";
  import customSelect from "../assets/js/customSelect";
  import popups from "../assets/js/popups";
  import scroll from "../assets/js/scroll";
  import input from "../assets/js/input";
  import newCustomSelect from "../assets/js/newCustomSelect";
  import OnboardingModal from "../pages/Onboarding";
  import {
    addPlanetToUser,
    createUser,
    getAllUserPlanets,
    getNfts,
    getPlanetByName,
    getUserByTgId,
    getUser,
  } from "../utils/axios";
  import { ColorRing } from "react-loader-spinner";
  import { Outlet } from "react-router-dom";
  
  // –í–∞—à–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
  export const DataContext = createContext();

  export async function updateUserTgId(userId, tgId, userName) {
  const response = await fetch(`https://playmost.ru/api2/update_tgid`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ userId, tgId, userName }),
  });

  if (!response.ok) {
    throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å tg_id");
  }

  return await response.json();
}

  
  export default function Layout({ without = false }) {
    const adress = useTonAddress();
    const wallet = useTonWallet();
    const connectionRestored = useIsConnectionRestored();
  
    const [isLoading, setIsLoading] = useState(true);
    const [isFetched, setIsFetched] = useState(false);
    const [tgUser, setTgUser] = useState(null);
    const [showOnboarding, setShowOnboarding] = useState(false);

    
    

    async function getWalletFromBackend(userId) {
  try {
    const response = await fetch('https://playmost.ru/api2/get-wallet', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ user_id: userId }),
    });

    if (!response.ok) {
      throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –æ –∫–æ—à–µ–ª—å–∫–µ');
    }

    const data = await response.json();

    // üîç –£–¥–∞–ª–∏–º –¥—É–±–ª–∏ –ø–æ element + name
    if (data?.value && Array.isArray(data.value)) {
      const seen = new Set();
      data.value = data.value.filter(item => {
        const key = `${item.element}_${item.name}`;
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      });

      // –õ–æ–≥ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
      const ids = data.value.map(i => `${i.element}_${i.name}`);
      const duplicates = ids.filter((id, idx) => ids.indexOf(id) !== idx);
      if (duplicates.length) {
        console.warn("‚ö†Ô∏è –î—É–±–ª–∏ –Ω–µ —É–¥–∞–ª–∏–ª–∏—Å—å –ø–æ–ª–Ω–æ—Å—Ç—å—é:", duplicates);
      }
    }

    return data;
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–æ—à–µ–ª—å–∫–∞:', error);
    return null;
  }
}

      const getShipNfts = async (address) => {
        console.log("–Ø —Å–æ–±–∏—Ä–∞—é –¥–∞–Ω–Ω—ã–µ –æ –∫–æ—Ä–∞–±–ª—è—Ö");
        // const adress = 'UQBSZ-ZXsaxOHpOa8ekXgJDeboj792Z0alKGUU5r_i9vTOZU';
        // const adress = 'UQBSZ-ZXsaxOHpOa8ekXgJDeboj792Z0alKGUU5r_i9vTOZU';
        const apiUrl = `https://tonapi.io/v2/accounts/${address}/nfts?collection=EQA_qbGrlmx4g8QRqiY6-G5ipLHDkl03hUmsnlI382IRt7uP&limit=1000&offset=0&indirect_ownership=true`;
        
        const response = await fetch(apiUrl, {
            headers: {
                "Accept": "application/json"
                // –î–æ–±–∞–≤—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                // "Authorization": "Bearer YOUR_TOKEN"
            }
        });
    
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }
    
        const data = await response.json();
        console.log("NFT",data);
        return data.nft_items;
    };

    const checkNftInDatabase = async (index) => {
      try {
          const response = await fetch(`https://playmost.ru/api2/check_nft/${index}`, {
              method: 'GET',
          });
          const data = await response.json();
          return data.exists; // –ü—Ä–∏–º–∏—Ç–µ, —á—Ç–æ API –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç { exists: true/false }
      } catch (error) {
          console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ NFT –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö:", error);
          return false; // –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ NFT –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
      }
  };

  const addNftToDatabase = async (nft,userId) => {
    try {
      const ns = nft.metadata.attributes.find(attr => attr.trait_type === "Power").value;
      console.log("NS",ns);
        const response = await fetch('https://playmost.ru/api2/add_nft', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                userId: userId,
                index: nft.index,
                name: nft.metadata.name,
                tonnage: nft.metadata.attributes.find(attr => attr.trait_type === "Tonnage").value,
                shot: nft.metadata.attributes.find(attr => attr.trait_type === "Shot").value,
                power: ns,
                // –î–æ–±–∞–≤—å—Ç–µ –¥—Ä—É–≥–∏–µ –∞—Ç—Ä–∏–±—É—Ç—ã, –µ—Å–ª–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ
            }),
        });
        const data = await response.json();
        console.log("NFT –¥–æ–±–∞–≤–ª–µ–Ω–æ:", data);
    } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ NFT –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö:", error);
    }
};
      
  
    useEffect(() => {
  const telegram = window?.Telegram?.WebApp;
  const user = telegram?.initDataUnsafe?.user;

  const initTgUser = async () => {
    if (user) {
      setTgUser({
        id: user.id,
        username: user.username || "Anonymous",
      });

      // try {
      //   // const currentUser = JSON.parse(localStorage.getItem("user")); // –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –±—ã–ª —Å–æ—Ö—Ä–∞–Ω—ë–Ω —Ä–∞–Ω–µ–µ
      //   // if (currentUser && currentUser.tg_id !== user.id) {
      //     await updateUserTgId(window.user.id, user.id);
      //   // }
      // } catch (err) {
      //   console.warn("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å tg_id:", err);
      // }
    } else {
      // –î–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –±–µ–∑ Telegram
      setTgUser({
        id: 9999,
        username: "dev_user",
      });
    }
  };

  initTgUser();
}, []);

  
    useEffect(() => {
      const init = async () => {
        if (!connectionRestored || !tgUser || isFetched) return;
        setIsFetched(true);
        setIsLoading(true);
    
        try {
          console.log("üîÑ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è...");
          console.log("–ü—Ä–æ–≤–µ—Ä—è–µ–º tgUser –∏ adress:", tgUser, adress);
    
          // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
          if (!tgUser?.id || !tgUser?.username) {
            throw new Error("–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.");
          }
          try {
            if (tgUser?.id ) {
              await updateUserTgId(window.user.id, tgUser.id, tgUser.username);
              user.tg_id = tgUser.id; // –Ω–µ –∑–∞–±—É–¥—å –æ–±–Ω–æ–≤–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–π –æ–±—ä–µ–∫—Ç
            }
          } catch (err) {
            console.warn("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ tg_id:", err);
          }
    
          let user = null;
    
          if (adress) {
            // üîê –ï—Å–ª–∏ –∞–¥—Ä–µ—Å –µ—Å—Ç—å ‚Äî —Ä–∞–±–æ—Ç–∞–µ–º —Å —Ä–µ–∞–ª—å–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
            user = await getUserByTgId(tgUser.id);

if (!user) {
  user = await getUser(adress);

  // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–π–¥–µ–Ω –ø–æ –∞–¥—Ä–µ—Å—É, –Ω–æ –Ω–µ —Å–≤—è–∑–∞–Ω —Å tg_id
  if (user && !user.tg_id &&  tgUser.id!=9999) {
    try {
      await updateUserTgId(user.id, tgUser.id,tgUser.username);
      user.tg_id = tgUser.id;
    } catch (err) {
      console.warn("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–≤—è–∑—ã–≤–∞–Ω–∏–∏ tg_id:", err);
    }
  }
}

// –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–æ–æ–±—â–µ –Ω–µ –Ω–∞–π–¥–µ–Ω ‚Äî —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ
if (!user) {
  user = await createUser({
    tg_id: tgUser.id,
    userName: tgUser.username,
    adress,
  });
}

    
            // –û–±–Ω–æ–≤–∏–º –∞–¥—Ä–µ—Å –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
            try{
            if (user.adress !== adress) {
              await updateUserAdress(user.id, adress);
            }
          } catch {
            console.log("–ê–ì–ê")
          }
    
            // –ü–æ–ª—É—á–∞–µ–º –∫–æ—à–µ–ª–µ–∫
            try{
            const walletData = await getWalletFromBackend(user.id);
            if (walletData) {
              user.wallet = walletData;
            }
          } catch {
            console.log("–ê–ì–ê2")
          }
    
            // NFT + –ü–ª–∞–Ω–µ—Ç—ã
            try{
            const nfts = await getNfts(user.adress);
            if (nfts) {
              user.nft = nfts;
    
              const allUserPlanets = await getAllUserPlanets();
              for (const item of nfts) {
                const planetName = item.metadata?.name?.split('(')[0];
                const planet = await getPlanetByName({ name: planetName });
    
                if (planet?.id && !allUserPlanets.some(val => val?.planetId === planet.id)) {
                  await addPlanetToUser(planet.id);
                }
              }
            }
          } catch {
            console.log("–ê–ì–ê3")
          }
try{
      
      } catch {
        console.log("–ê–ì–ê4")
      }
    
          } else {
            // ‚ùå –ù–µ—Ç –∞–¥—Ä–µ—Å–∞ ‚Äî —Å–æ–∑–¥–∞—ë–º —Ñ–∏–∫—Ç–∏–≤–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            user = {
              id: 9999,
              tg_id: null,
              userName: null,
              adress: null,
              wallet: null,
              nft: [],
            };
            console.warn("‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –±–µ–∑ –∞–¥—Ä–µ—Å–∞ ‚Äî —Ç–æ–ª—å–∫–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª.");
          }
    
          window.user = user;
          localStorage.setItem("user", JSON.stringify(user));
    
        } catch (e) {
          console.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:", e);
        } finally {
          setIsLoading(false);
        }
      };
    
      init();
    }, [connectionRestored, adress, tgUser]);


    useEffect(() => {
      const loadNFTsInBackground = async () => {
        const user = window.user;
        if (!user?.adress || !user?.id) return;
    
        try {
          console.log("üöÄ –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ—Ä–∞–±–ª–∏ –≤ —Ñ–æ–Ω–µ...");
          // const ships = await getShipNfts(user.adress);
          // if (ships?.length) {
          //   for (const item of ships) {
          //     const exists = await checkNftInDatabase(item.index);
          //     if (!exists) {
          //       await addNftToDatabase(item, user.id);
          //     }
          //   }
          // }
        } catch (e) {
          console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ–Ω–æ–≤–æ–π –∑–∞–≥—Ä—É–∑–∫–µ NFT:", e);
        }
      };
    
      loadNFTsInBackground();
    }, [window.user?.adress]);
    
    
  
    // UI —Å–∫—Ä–∏–ø—Ç—ã
    useEffect(() => {
      if (!isLoading) {
        marketAdaptiv();
        customSelect();
        popups();
        without ? "" : scroll();
        input();
        newCustomSelect();
      }
    }, [isLoading]);

    useEffect(() => {
          if (!isLoading) {
            const seen = localStorage.getItem("onboardingSeen");
            if (!seen) {
              setShowOnboarding(true);
            }
          }
        }, [isLoading]);
  
    return !isLoading ? (
      <DataContext.Provider value={{ user: window.user, isLoading }}>
        {!without && <Header />}
        {showOnboarding && (
  <OnboardingModal onClose={() => {
    localStorage.setItem("onboardingSeen", "true");
    setShowOnboarding(false);
  }} />
)}
        <main className={`main ${without ? "without" : ""}`}>
          <div className={`${without ? "without" : "container"}`}>
            <Outlet />
          </div>
        </main>
        {!without && <Footer />}
      </DataContext.Provider>
    ) : (
      <div className="color-ring-wrapper">
        <ColorRing
          visible={isLoading}
          height={80}
          width={80}
          colors={['#e15b64', '#f47e60', '#f8b26a', '#abbd81', '#849b87']}
        />
      </div>
    );
  }
  


  